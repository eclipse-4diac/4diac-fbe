#********************************************************************************
# Copyright (c) 2018, 2024 OFFIS e.V.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0.
#
# SPDX-License-Identifier: EPL-2.0
# 
# Contributors:
#    JÃ¶rg Walter - initial implementation
# *******************************************************************************/
#

diff --git a/Drivers/FreeRTOS-Plus-TCP/include/FreeRTOSIPConfig.h b/Drivers/FreeRTOS-Plus-TCP/include/FreeRTOSIPConfig.h
index 655c7bc..d17e866 100644
--- a/Drivers/FreeRTOS-Plus-TCP/include/FreeRTOSIPConfig.h
+++ b/Drivers/FreeRTOS-Plus-TCP/include/FreeRTOSIPConfig.h
@@ -58,29 +58,240 @@
 #ifndef FREERTOS_IP_CONFIG_H
 #define FREERTOS_IP_CONFIG_H
 
-#include <mem.h>
+#include <debug-printf.h>
 
-#define FreeRTOS_debug_print = 0
-// #define FreeRTOS_debug_printf( MSG ) println(MSG, 0xFFFFFFFF);
+#define FreeRTOS_debug_printf( MSG ) debug_printf MSG
+#define ipconfigHAS_DEBUG_PRINTF	1
 
-/*Optional: ipconfigPACKET_FILLER_SIZE This option is a bit tricky:
-it makes sure that all 32-bit fields in the network packets are 32-bit aligned.
-This means that the 14-byte Ethernet header should start at a 16-bit offset.
-Therefore ipconfigPACKET_FILLER_SIZE is defined a 2 (bytes).
-I think that most EMAC's have an option to set this 2-byte offset for both incoming and outgoing packets.*/
-#define ipconfigPACKET_FILLER_SIZE 0
+#define FreeRTOS_printf( MSG ) debug_printf MSG
+#define ipconfigHAS_PRINTF	1
 
-#define portTICK_PERIOD_MS portTICK_RATE_MS
-#define pdMS_TO_TICKS( xTimeInMs ) ( ( portTickType ) xTimeInMs * ( configTICK_RATE_HZ / ( ( portTickType ) 1000 ) ) )
+#define ipconfigBYTE_ORDER pdFREERTOS_LITTLE_ENDIAN
 
-//The size, in words (not bytes), of the stack allocated to the FreeRTOS+TCP RTOS task.
-#define ipconfigIP_TASK_STACK_SIZE_WORDS 1024
+/* Several API's will block until the result is known, or the action has been
+performed, for example FreeRTOS_send() and FreeRTOS_recv().  The timeouts can be
+set per socket, using setsockopt().  If not set, the times below will be
+used as defaults. */
+#define ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME	( 5000 )
+#define	ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME	( 5000 )
 
-//sets the priority of the RTOS task that executes the TCP/IP stack.
-#define ipconfigIP_TASK_PRIORITY 1
+/* Include support for LLMNR: Link-local Multicast Name Resolution
+(non-Microsoft) */
+#define ipconfigUSE_LLMNR					( 0 )
 
-//To use volatile list structure members
-#define configLIST_VOLATILE volatile
+/* Include support for NBNS: NetBIOS Name Service (Microsoft) */
+#define ipconfigUSE_NBNS					( 0 )
+
+/* Include support for DNS caching.  For TCP, having a small DNS cache is very
+useful.  When a cache is present, ipconfigDNS_REQUEST_ATTEMPTS can be kept low
+and also DNS may use small timeouts.  If a DNS reply comes in after the DNS
+socket has been destroyed, the result will be stored into the cache.  The next
+call to FreeRTOS_gethostbyname() will return immediately, without even creating
+a socket. */
+#define ipconfigUSE_DNS_CACHE				( 1 )
+#define ipconfigDNS_CACHE_NAME_LENGTH		( 16 )
+#define ipconfigDNS_CACHE_ENTRIES			( 4 )
+#define ipconfigDNS_REQUEST_ATTEMPTS		( 2 )
+
+/* The IP stack executes it its own task (although any application task can make
+use of its services through the published sockets API). ipconfigUDP_TASK_PRIORITY
+sets the priority of the task that executes the IP stack.  The priority is a
+standard FreeRTOS task priority so can take any value from 0 (the lowest
+priority) to (configMAX_PRIORITIES - 1) (the highest priority).
+configMAX_PRIORITIES is a standard FreeRTOS configuration parameter defined in
+FreeRTOSConfig.h, not FreeRTOSIPConfig.h. Consideration needs to be given as to
+the priority assigned to the task executing the IP stack relative to the
+priority assigned to tasks that use the IP stack. */
+#define ipconfigIP_TASK_PRIORITY			( configMAX_PRIORITIES - 2 )
+
+/* The size, in words (not bytes), of the stack allocated to the FreeRTOS+TCP
+task.  This setting is less important when the FreeRTOS Win32 simulator is used
+as the Win32 simulator only stores a fixed amount of information on the task
+stack.  FreeRTOS includes optional stack overflow detection, see:
+http://www.freertos.org/Stacks-and-stack-overflow-checking.html */
+#define ipconfigIP_TASK_STACK_SIZE_WORDS	( configMINIMAL_STACK_SIZE * 5 )
+
+/* ipconfigRAND32() is called by the IP stack to generate random numbers for
+things such as a DHCP transaction number or initial sequence number.  Random
+number generation is performed via this macro to allow applications to use their
+own random number generation method.  For example, it might be possible to
+generate a random number by sampling noise on an analogue input. */
+extern UBaseType_t uxRand();
+#define ipconfigRAND32()	uxRand()
+
+/* If ipconfigUSE_NETWORK_EVENT_HOOK is set to 1 then FreeRTOS+TCP will call the
+network event hook at the appropriate times.  If ipconfigUSE_NETWORK_EVENT_HOOK
+is not set to 1 then the network event hook will never be called.  See
+http://www.FreeRTOS.org/FreeRTOS-Plus/FreeRTOS_Plus_UDP/API/vApplicationIPNetworkEventHook.shtml
+*/
+#define ipconfigUSE_NETWORK_EVENT_HOOK 0
+
+/* Sockets have a send block time attribute.  If FreeRTOS_sendto() is called but
+a network buffer cannot be obtained then the calling task is held in the Blocked
+state (so other tasks can continue to executed) until either a network buffer
+becomes available or the send block time expires.  If the send block time expires
+then the send operation is aborted.  The maximum allowable send block time is
+capped to the value set by ipconfigMAX_SEND_BLOCK_TIME_TICKS.  Capping the
+maximum allowable send block time prevents prevents a deadlock occurring when
+all the network buffers are in use and the tasks that process (and subsequently
+free) the network buffers are themselves blocked waiting for a network buffer.
+ipconfigMAX_SEND_BLOCK_TIME_TICKS is specified in RTOS ticks.  A time in
+milliseconds can be converted to a time in ticks by dividing the time in
+milliseconds by portTICK_PERIOD_MS. */
+#define ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS ( 5000U / portTICK_PERIOD_MS )
+
+/* If ipconfigUSE_DHCP is 1 then FreeRTOS+TCP will attempt to retrieve an IP
+address, netmask, DNS server address and gateway address from a DHCP server.  If
+ipconfigUSE_DHCP is 0 then FreeRTOS+TCP will use a static IP address.  The
+stack will revert to using the static IP address even when ipconfigUSE_DHCP is
+set to 1 if a valid configuration cannot be obtained from a DHCP server for any
+reason.  The static configuration used is that passed into the stack by the
+FreeRTOS_IPInit() function call. */
+#define ipconfigUSE_DHCP	1
+
+/* When ipconfigUSE_DHCP is set to 1, DHCP requests will be sent out at
+increasing time intervals until either a reply is received from a DHCP server
+and accepted, or the interval between transmissions reaches
+ipconfigMAXIMUM_DISCOVER_TX_PERIOD.  The IP stack will revert to using the
+static IP address passed as a parameter to FreeRTOS_IPInit() if the
+re-transmission time interval reaches ipconfigMAXIMUM_DISCOVER_TX_PERIOD without
+a DHCP reply being received. */
+#define ipconfigMAXIMUM_DISCOVER_TX_PERIOD		( 120000U / portTICK_PERIOD_MS )
+
+/* The ARP cache is a table that maps IP addresses to MAC addresses.  The IP
+stack can only send a UDP message to a remove IP address if it knowns the MAC
+address associated with the IP address, or the MAC address of the router used to
+contact the remote IP address.  When a UDP message is received from a remote IP
+address the MAC address and IP address are added to the ARP cache.  When a UDP
+message is sent to a remote IP address that does not already appear in the ARP
+cache then the UDP message is replaced by a ARP message that solicits the
+required MAC address information.  ipconfigARP_CACHE_ENTRIES defines the maximum
+number of entries that can exist in the ARP table at any one time. */
+#define ipconfigARP_CACHE_ENTRIES		6
+
+/* ARP requests that do not result in an ARP response will be re-transmitted a
+maximum of ipconfigMAX_ARP_RETRANSMISSIONS times before the ARP request is
+aborted. */
+#define ipconfigMAX_ARP_RETRANSMISSIONS ( 5 )
+
+/* ipconfigMAX_ARP_AGE defines the maximum time between an entry in the ARP
+table being created or refreshed and the entry being removed because it is stale.
+New ARP requests are sent for ARP cache entries that are nearing their maximum
+age.  ipconfigMAX_ARP_AGE is specified in tens of seconds, so a value of 150 is
+equal to 1500 seconds (or 25 minutes). */
+#define ipconfigMAX_ARP_AGE			150
+
+/* Implementing FreeRTOS_inet_addr() necessitates the use of string handling
+routines, which are relatively large.  To save code space the full
+FreeRTOS_inet_addr() implementation is made optional, and a smaller and faster
+alternative called FreeRTOS_inet_addr_quick() is provided.  FreeRTOS_inet_addr()
+takes an IP in decimal dot format (for example, "192.168.0.1") as its parameter.
+FreeRTOS_inet_addr_quick() takes an IP address as four separate numerical octets
+(for example, 192, 168, 0, 1) as its parameters.  If
+ipconfigINCLUDE_FULL_INET_ADDR is set to 1 then both FreeRTOS_inet_addr() and
+FreeRTOS_indet_addr_quick() are available.  If ipconfigINCLUDE_FULL_INET_ADDR is
+not set to 1 then only FreeRTOS_indet_addr_quick() is available. */
+#define ipconfigINCLUDE_FULL_INET_ADDR	1
+
+/* ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS defines the total number of network buffer that
+are available to the IP stack.  The total number of network buffers is limited
+to ensure the total amount of RAM that can be consumed by the IP stack is capped
+to a pre-determinable value. */
+#define ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS		60
+
+/* A FreeRTOS queue is used to send events from application tasks to the IP
+stack.  ipconfigEVENT_QUEUE_LENGTH sets the maximum number of events that can
+be queued for processing at any one time.  The event queue must be a minimum of
+5 greater than the total number of network buffers. */
+#define ipconfigEVENT_QUEUE_LENGTH		( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS + 5 )
+
+/* The address of a socket is the combination of its IP address and its port
+number.  FreeRTOS_bind() is used to manually allocate a port number to a socket
+(to 'bind' the socket to a port), but manual binding is not normally necessary
+for client sockets (those sockets that initiate outgoing connections rather than
+wait for incoming connections on a known port number).  If
+ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND is set to 1 then calling
+FreeRTOS_sendto() on a socket that has not yet been bound will result in the IP
+stack automatically binding the socket to a port number from the range
+socketAUTO_PORT_ALLOCATION_START_NUMBER to 0xffff.  If
+ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND is set to 0 then calling FreeRTOS_sendto()
+on a socket that has not yet been bound will result in the send operation being
+aborted. */
+#define ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND 1
+
+/* Defines the Time To Live (TTL) values used in outgoing UDP packets. */
+#define ipconfigUDP_TIME_TO_LIVE		128
+#define ipconfigTCP_TIME_TO_LIVE		128 /* also defined in FreeRTOSIPConfigDefaults.h */
+
+/* USE_TCP: Use TCP and all its features */
+#define ipconfigUSE_TCP				( 1 )
+
+/* USE_WIN: Let TCP use windowing mechanism. */
+#define ipconfigUSE_TCP_WIN			( 1 )
+
+/* The MTU is the maximum number of bytes the payload of a network frame can
+contain.  For normal Ethernet V2 frames the maximum MTU is 1500.  Setting a
+lower value can save RAM, depending on the buffer management scheme used.  If
+ipconfigCAN_FRAGMENT_OUTGOING_PACKETS is 1 then (ipconfigNETWORK_MTU - 28) must
+be divisible by 8. */
+#define ipconfigNETWORK_MTU		1200U
+
+/* Set ipconfigUSE_DNS to 1 to include a basic DNS client/resolver.  DNS is used
+through the FreeRTOS_gethostbyname() API function. */
+#define ipconfigUSE_DNS			0
+
+/* If ipconfigREPLY_TO_INCOMING_PINGS is set to 1 then the IP stack will
+generate replies to incoming ICMP echo (ping) requests. */
+#define ipconfigREPLY_TO_INCOMING_PINGS				1
+
+/* If ipconfigSUPPORT_OUTGOING_PINGS is set to 1 then the
+FreeRTOS_SendPingRequest() API function is available. */
+#define ipconfigSUPPORT_OUTGOING_PINGS				0
+
+/* If ipconfigSUPPORT_SELECT_FUNCTION is set to 1 then the FreeRTOS_select()
+(and associated) API function is available. */
+#define ipconfigSUPPORT_SELECT_FUNCTION				1
+
+/* If ipconfigFILTER_OUT_NON_ETHERNET_II_FRAMES is set to 1 then Ethernet frames
+that are not in Ethernet II format will be dropped.  This option is included for
+potential future IP stack developments. */
+#define ipconfigFILTER_OUT_NON_ETHERNET_II_FRAMES  1
+
+/* Advanced only: in order to access 32-bit fields in the IP packets with
+32-bit memory instructions, all packets will be stored 32-bit-aligned, plus 16-bits.
+This has to do with the contents of the IP-packets: all 32-bit fields are
+32-bit-aligned, plus 16-bit(!) */
+#define ipconfigPACKET_FILLER_SIZE 2U
+
+/* Define the size of the pool of TCP window descriptors.  On the average, each
+TCP socket will use up to 2 x 6 descriptors, meaning that it can have 2 x 6
+outstanding packets (for Rx and Tx).  When using up to 10 TP sockets
+simultaneously, one could define TCP_WIN_SEG_COUNT as 120. */
+#define ipconfigTCP_WIN_SEG_COUNT		240
+
+/* Each TCP socket has a circular buffers for Rx and Tx, which have a fixed
+maximum size.  Define the size of Rx buffer for TCP sockets. */
+#define ipconfigTCP_RX_BUFFER_LENGTH			( 1000 )
+
+/* Define the size of Tx buffer for TCP sockets. */
+#define ipconfigTCP_TX_BUFFER_LENGTH			( 1000 )
+
+/* When using call-back handlers, the driver may check if the handler points to
+real program memory (RAM or flash) or just has a random non-zero value. */
+#define ipconfigIS_VALID_PROG_ADDRESS(x) ( (x) != NULL )
+
+/* Include support for TCP hang protection.  All sockets in a connecting or
+disconnecting stage will timeout after a period of non-activity. */
+#define ipconfigTCP_HANG_PROTECTION			( 1 )
+#define ipconfigTCP_HANG_PROTECTION_TIME	( 30 )
+
+/* Include support for TCP keep-alive messages. */
+#define ipconfigTCP_KEEP_ALIVE				( 1 )
+#define ipconfigTCP_KEEP_ALIVE_INTERVAL		( 20 ) /* in seconds */
+
+#define portINLINE inline
+
+//#define pdMS_TO_TICKS( xTimeInMs ) ( ( portTickType ) xTimeInMs * ( configTICK_RATE_HZ / ( ( portTickType ) 1000 ) ) )
 
 #define configEMAC_TASK_STACK_SIZE 1024
 
diff --git a/Drivers/FreeRTOS-Plus-TCP/portable/NetworkInterface.c b/Drivers/FreeRTOS-Plus-TCP/portable/NetworkInterface.c
index eb52117..4708a63 100644
--- a/Drivers/FreeRTOS-Plus-TCP/portable/NetworkInterface.c
+++ b/Drivers/FreeRTOS-Plus-TCP/portable/NetworkInterface.c
@@ -11,6 +11,9 @@
 #include "NetworkBufferManagement.h"
 #include "NetworkInterface.h"
 
+#include "uspi.h"
+#include <debug-printf.h>
+
 /* The queue used to pass events into the IP-task for processing. */
 xQueueHandle xOutputQueue = NULL;
 
@@ -27,9 +30,6 @@ void ethernetPollTask(){
 	const portTickType xBlockTime = pdMS_TO_TICKS( 100UL );
 	static IPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };
 
-	//create a queue to store addresses of NetworkBufferDescriptors
-	xOutputQueue = xQueueCreate( ( unsigned portBASE_TYPE ) ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, 4 );
-
 	for( ;; ){
 		//send any waiting packets first
 		for(int i = 0; i < uxQueueMessagesWaiting(xOutputQueue); i++){
@@ -100,15 +100,31 @@ void ethernetPollTask(){
 }
 
 portBASE_TYPE xNetworkInterfaceInitialise(){
+	debug_printf_str("> xNetworkInterfaceInitialise\n");
 	if (!USPiInitialize ()){
-		println("Cannot initialize USPi", 0xFFFFFFFF);
+		debug_printf_str("  fail\n");
 		return pdFAIL;
 	}
+	debug_printf_str("> xqeue1\n");
+
+	// create a queue to store addresses of NetworkBufferDescriptors
+	xOutputQueue = xQueueCreate( ( unsigned portBASE_TYPE ) ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, 4 );
+
+	debug_printf_str("> memcpy\n");
+    uint8_t ucMACAddress[6];
+    USPiGetMACAddress(ucMACAddress);
+    memcpy( ( void * ) ipLOCAL_MAC_ADDRESS, ( void * ) ucMACAddress, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
+
+	debug_printf_str("> xqueue2\n");
+	//create a queue to store addresses of NetworkBufferDescriptors
+	xOutputQueue = xQueueCreate( ( unsigned portBASE_TYPE ) ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, 4 );
 
+	debug_printf_str("> queues\n");
 	if (!USPiEthernetAvailable ()){
-		println("Ethernet device not found", 0xFFFFFFFF);
 		return pdFAIL;
+		debug_printf_str("> !available\n");
 	}
+	debug_printf_str("> available\n");
 
 	xTaskCreate(ethernetPollTask, "poll", 128, NULL, 0, NULL);
 
diff --git a/Drivers/interrupts.c b/Drivers/interrupts.c
index 39d91e7..36b75c2 100644
--- a/Drivers/interrupts.c
+++ b/Drivers/interrupts.c
@@ -6,6 +6,7 @@
 #include "interrupts.h"
 #include "bcm2835_intc.h"
 #include "video.h"
+#include <debug-printf.h>
 static INTERRUPT_VECTOR g_VectorTable[BCM2835_INTC_TOTAL_IRQ];
 
 
@@ -56,29 +57,34 @@ void irqHandler() {
 
 	/* Bits 7 through 0 in IRQBasic represent interrupts 64-71 */
 	if (ulMaskedStatus & 0xFF) {
+//		debug_putc('@');
 		irqNumber=64 + 31;
 	}
 
 	/* Bit 8 in IRQBasic indicates interrupts in Pending1 (interrupts 31-0) */
 	else if(ulMaskedStatus & 0x100) {
+//		debug_putc('$');
 		ulMaskedStatus = pRegs->Pending1;
 		irqNumber = 0 + 31;
 	}
 
 	/* Bit 9 in IRQBasic indicates interrupts in Pending2 (interrupts 63-32) */
 	else if(ulMaskedStatus & 0x200) {
+//		debug_putc('#');
 		ulMaskedStatus = pRegs->Pending2;
 		irqNumber = 32 + 31;
 	}
 
 	/* Bit 11 in IRQBasic indicates interrupt 9 (USB)*/
 	else if(ulMaskedStatus & 0x800) {
+//		debug_putc('u');
 			g_VectorTable[9].pfnHandler(9, g_VectorTable[9].pParam);
 			return;
 	}
 
 	else {
 		// No interrupt available, so just return.
+		extern void vLocalTickISR(); vLocalTickISR();
 		return;
 	}
 
@@ -87,23 +93,23 @@ void irqHandler() {
 	/* Some magic to determine number of interrupt to serve */
 	irqNumber=irqNumber-clz(ulMaskedStatus);
 	/* Call interrupt handler */
+//	debug_putc('0'+(irqNumber/100)%10);
+//	debug_putc('0'+(irqNumber/10)%10);
+//	debug_putc('0'+irqNumber%10);
 	g_VectorTable[irqNumber].pfnHandler(irqNumber, g_VectorTable[irqNumber].pParam);
+//	debug_putc('%');
 }
 
-__attribute__((no_instrument_function))
-static void stubHandler(int nIRQ, void *pParam) {
-	/**
-	 *	Actually if we get here, we should probably disable the IRQ,
-	 *	otherwise we could lock up this system, as there is nothing to
-	 *	ackknowledge the interrupt.
-	 **/
-}
+/* This emulates the generic IRQ callback mechanisms as present in modern ARM
+ * ports of FreeRTOS. To use this, use EnableInterrupt without setting a custom
+ * interrupt handler via RegisterInterrupt. */
+extern void vApplicationIRQHandler(int, void*);
 
 __attribute__((no_instrument_function))
 int InitInterruptController() {
 	int i;
 	for(i = 0; i < BCM2835_INTC_TOTAL_IRQ; i++) {
-		g_VectorTable[i].pfnHandler 	= stubHandler;
+		g_VectorTable[i].pfnHandler 	= vApplicationIRQHandler;
 		g_VectorTable[i].pParam			= (void *) 0;
 	}
 	return 0;
diff --git a/Drivers/lan9514/include/uspi/types.h b/Drivers/lan9514/include/uspi/types.h
index a362c7a..00d332c 100644
--- a/Drivers/lan9514/include/uspi/types.h
+++ b/Drivers/lan9514/include/uspi/types.h
@@ -20,7 +20,7 @@
 #ifndef _uspi_types_h
 #define _uspi_types_h
 
-#include "FreeRTOS.h"
+#include <stddef.h>
 
 typedef unsigned char		u8;
 typedef unsigned short		u16;
diff --git a/Drivers/lan9514/include/uspios.h b/Drivers/lan9514/include/uspios.h
index b88e84b..c4c17a7 100644
--- a/Drivers/lan9514/include/uspios.h
+++ b/Drivers/lan9514/include/uspios.h
@@ -40,8 +40,6 @@ extern "C" {
 //#define USPI_DEFAULT_KEYMAP_DE
 
 // Undefine this if you want to use your own implementation of the functions in uspi/util.h
-#define USPI_PROVIDE_MEM_FUNCTIONS	// mem*()
-#define USPI_PROVIDE_STR_FUNCTIONS	// str*()
 
 //
 // Memory allocation
diff --git a/Drivers/lan9514/lib/dwhcidevice.c b/Drivers/lan9514/lib/dwhcidevice.c
index f464239..eb56a80 100644
--- a/Drivers/lan9514/lib/dwhcidevice.c
+++ b/Drivers/lan9514/lib/dwhcidevice.c
@@ -22,8 +22,7 @@
 // You should have received a copy of the GNU General Public License
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
-#include "FreeRTOS.h"
-#include "task.h"
+#define portYIELD_WITHIN_API() __asm volatile ( "SWI 0" )
 
 #include <uspi/dwhcidevice.h>
 #include <uspios.h>
@@ -31,6 +30,7 @@
 #include <uspi/synchronize.h>
 #include <uspi/assert.h>
 #include "video.h"
+#include <debug-printf.h>
 #define ARM_IRQ_USB		9		// for ConnectInterrupt()
 
 #define DEVICE_ID_USB_HCD	3		// for SetPowerStateOn()
@@ -114,10 +114,12 @@ void _DWHCIDevice (TDWHCIDevice *pThis)
 
 boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 {
+	debug_printf_str(">>> DWHCIDeviceInitialize\n");
 	assert (pThis != 0);
 
 	DataMemBarrier ();
 
+	debug_printf_str(">>> register\n");
 	TDWHCIRegister VendorId;
 	DWHCIRegister (&VendorId, DWHCI_CORE_VENDOR_ID);
 	if (DWHCIRegisterRead (&VendorId) != 0x4F54280A)
@@ -127,6 +129,7 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 		return FALSE;
 	}
 
+	debug_printf_str(">>> power\n");
 	if (!SetPowerStateOn (DEVICE_ID_USB_HCD))
 	{
 		LogWrite (FromDWHCI, LOG_ERROR, "Cannot power on");
@@ -134,6 +137,7 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 		return FALSE;
 	}
 	
+	debug_printf_str(">>> irq\n");
 	// Disable all interrupts
 	TDWHCIRegister AHBConfig;
 	DWHCIRegister (&AHBConfig, DWHCI_CORE_AHB_CFG);
@@ -143,6 +147,7 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 
 	ConnectInterrupt (ARM_IRQ_USB, DWHCIDeviceInterruptHandler, pThis);
 
+	debug_printf_str(">>> initcore\n");
 	if (!DWHCIDeviceInitCore (pThis))
 	{
 		LogWrite (FromDWHCI, LOG_ERROR, "Cannot initialize core");
@@ -151,8 +156,10 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 		return FALSE;
 	}
 	
+	debug_printf_str(">>> global interrupts\n");
 	DWHCIDeviceEnableGlobalInterrupts (pThis);
 	
+	debug_printf_str(">>> init host\n");
 	if (!DWHCIDeviceInitHost (pThis))
 	{
 		LogWrite (FromDWHCI, LOG_ERROR, "Cannot initialize host");
@@ -164,6 +171,7 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 	// The following calls will fail if there is no device or no supported device connected
 	// to root port. This is not an error because the system may run without an USB device.
 
+	debug_printf_str(">>> enableroot\n");
 	if (!DWHCIDeviceEnableRootPort (pThis))
 	{
 		LogWrite (FromDWHCI, LOG_WARNING, "No device connected to root port");
@@ -172,6 +180,7 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 		return TRUE;
 	}
 
+	debug_printf_str(">>> init root\n");
 	if (!DWHCIRootPortInitialize (&pThis->m_RootPort))
 	{
 		LogWrite (FromDWHCI, LOG_WARNING, "Cannot initialize root port");
@@ -181,6 +190,7 @@ boolean DWHCIDeviceInitialize (TDWHCIDevice *pThis)
 	}
 	
 	DataMemBarrier ();
+	debug_printf_str(">>> done\n");
 
 	_DWHCIRegister (&AHBConfig);
 	_DWHCIRegister (&VendorId);
@@ -249,6 +259,7 @@ int DWHCIDeviceControlMessage (TDWHCIDevice *pThis, TUSBEndpoint *pEndpoint,
 
 	int nResult = -1;
 
+	debug_printf_str("x> submitblocking\n");
 	if (DWHCIDeviceSubmitBlockingRequest (pThis, &URB))
 	{
 		nResult = USBRequestGetResultLength (&URB);
@@ -289,6 +300,7 @@ boolean DWHCIDeviceSubmitBlockingRequest (TDWHCIDevice *pThis, TUSBRequest *pURB
 	assert (pURB != 0);
 	USBRequestSetStatus (pURB, 0);
 	
+	debug_printf_str("x> gettype\n");
 	if (USBEndpointGetType (USBRequestGetEndpoint (pURB)) == EndpointTypeControl)
 	{
 		TSetupData *pSetup = USBRequestGetSetupData (pURB);
@@ -298,6 +310,7 @@ boolean DWHCIDeviceSubmitBlockingRequest (TDWHCIDevice *pThis, TUSBRequest *pURB
 		{
 			assert (USBRequestGetBufLen (pURB) > 0);
 			
+			debug_printf_str("x> transfer in\n");
 			if (   !DWHCIDeviceTransferStage (pThis, pURB, FALSE, FALSE)
 			    || !DWHCIDeviceTransferStage (pThis, pURB, TRUE,  FALSE)
 			    || !DWHCIDeviceTransferStage (pThis, pURB, FALSE, TRUE))
@@ -309,6 +322,7 @@ boolean DWHCIDeviceSubmitBlockingRequest (TDWHCIDevice *pThis, TUSBRequest *pURB
 		{
 			if (USBRequestGetBufLen (pURB) == 0)
 			{
+				debug_printf_str("x> transfer out 0\n");
 				if (   !DWHCIDeviceTransferStage (pThis, pURB, FALSE, FALSE)
 				    || !DWHCIDeviceTransferStage (pThis, pURB, TRUE,  TRUE))
 				{
@@ -317,6 +331,7 @@ boolean DWHCIDeviceSubmitBlockingRequest (TDWHCIDevice *pThis, TUSBRequest *pURB
 			}
 			else
 			{
+				debug_printf_str("x> transfer out\n");
 				if (   !DWHCIDeviceTransferStage (pThis, pURB, FALSE, FALSE)
 				    || !DWHCIDeviceTransferStage (pThis, pURB, FALSE, FALSE)
 				    || !DWHCIDeviceTransferStage (pThis, pURB, TRUE,  TRUE))
@@ -332,6 +347,7 @@ boolean DWHCIDeviceSubmitBlockingRequest (TDWHCIDevice *pThis, TUSBRequest *pURB
 		        || USBEndpointGetType (USBRequestGetEndpoint (pURB)) == EndpointTypeInterrupt);
 		assert (USBRequestGetBufLen (pURB) > 0);
 		
+		debug_printf_str("x> transfer other\n");
 		if (!DWHCIDeviceTransferStage (pThis, pURB, USBEndpointIsDirectionIn (USBRequestGetEndpoint (pURB)), FALSE))
 		{
 			return FALSE;
@@ -367,6 +383,7 @@ boolean DWHCIDeviceInitCore (TDWHCIDevice *pThis)
 {
 	assert (pThis != 0);
 
+	debug_printf_str(">>>> usbconfig\n");
 	TDWHCIRegister USBConfig;
 	DWHCIRegister (&USBConfig, DWHCI_CORE_USB_CFG);
 	DWHCIRegisterRead (&USBConfig);
@@ -374,23 +391,27 @@ boolean DWHCIDeviceInitCore (TDWHCIDevice *pThis)
 	DWHCIRegisterAnd (&USBConfig, ~DWHCI_CORE_USB_CFG_TERM_SEL_DL_PULSE);
 	DWHCIRegisterWrite (&USBConfig);
 
+	debug_printf_str(">>>> reset\n");
 	if (!DWHCIDeviceReset (pThis))
 	{
 		LogWrite (FromDWHCI, LOG_ERROR, "Reset failed");
 		return FALSE;
 	}
 
+	debug_printf_str(">>>> read\n");
 	DWHCIRegisterRead (&USBConfig);
 	DWHCIRegisterAnd (&USBConfig, ~DWHCI_CORE_USB_CFG_ULPI_UTMI_SEL);	// select UTMI+
 	DWHCIRegisterAnd (&USBConfig, ~DWHCI_CORE_USB_CFG_PHYIF);		// UTMI width is 8
 	DWHCIRegisterWrite (&USBConfig);
 
+	debug_printf_str(">>>> hciread\n");
 	// Internal DMA mode only
 	TDWHCIRegister HWConfig2;
 	DWHCIRegister (&HWConfig2, DWHCI_CORE_HW_CFG2);
 	DWHCIRegisterRead (&HWConfig2);
 	assert (DWHCI_CORE_HW_CFG2_ARCHITECTURE (DWHCIRegisterGet (&HWConfig2)) == 2);
 	
+	debug_printf_str(">>>> phy\n");
 	DWHCIRegisterRead (&USBConfig);
 	if (   DWHCI_CORE_HW_CFG2_HS_PHY_TYPE (DWHCIRegisterGet (&HWConfig2)) == DWHCI_CORE_HW_CFG2_HS_PHY_TYPE_ULPI
 	    && DWHCI_CORE_HW_CFG2_FS_PHY_TYPE (DWHCIRegisterGet (&HWConfig2)) == DWHCI_CORE_HW_CFG2_FS_PHY_TYPE_DEDICATED)
@@ -409,6 +430,7 @@ boolean DWHCIDeviceInitCore (TDWHCIDevice *pThis)
 	pThis->m_nChannels = DWHCI_CORE_HW_CFG2_NUM_HOST_CHANNELS (DWHCIRegisterGet (&HWConfig2));
 	assert (4 <= pThis->m_nChannels && pThis->m_nChannels <= DWHCI_MAX_CHANNELS);
 
+	debug_printf_str(">>>> ahbconfig\n");
 	TDWHCIRegister AHBConfig;
 	DWHCIRegister (&AHBConfig, DWHCI_CORE_AHB_CFG);
 	DWHCIRegisterRead (&AHBConfig);
@@ -419,12 +441,14 @@ boolean DWHCIDeviceInitCore (TDWHCIDevice *pThis)
 	//DWHCIRegisterOr (&AHBConfig, 0 << DWHCI_CORE_AHB_CFG_MAX_AXI_BURST__SHIFT);	// max. AXI burst length 4
 	DWHCIRegisterWrite (&AHBConfig);
 
+	debug_printf_str(">>>> hnp srp\n");
 	// HNP and SRP are not used
 	DWHCIRegisterRead (&USBConfig);
 	DWHCIRegisterAnd (&USBConfig, ~DWHCI_CORE_USB_CFG_HNP_CAPABLE);
 	DWHCIRegisterAnd (&USBConfig, ~DWHCI_CORE_USB_CFG_SRP_CAPABLE);
 	DWHCIRegisterWrite (&USBConfig);
 
+	debug_printf_str(">>>> int\n");
 	DWHCIDeviceEnableCommonInterrupts (pThis);
 
 	_DWHCIRegister (&AHBConfig);
@@ -554,6 +578,7 @@ boolean DWHCIDeviceReset (TDWHCIDevice *pThis)
 	TDWHCIRegister Reset;
 	DWHCIRegister2 (&Reset, DWHCI_CORE_RESET, 0);
 	
+	debug_printf_str(">>>>> wait\n");
 	// wait for AHB master IDLE state
 	if (!DWHCIDeviceWaitForBit (pThis, &Reset, DWHCI_CORE_RESET_AHB_IDLE, TRUE, 100))
 	{
@@ -562,10 +587,12 @@ boolean DWHCIDeviceReset (TDWHCIDevice *pThis)
 		return FALSE;
 	}
 	
+	debug_printf_str(">>>>> write\n");
 	// core soft reset
 	DWHCIRegisterOr (&Reset, DWHCI_CORE_RESET_SOFT_RESET);
 	DWHCIRegisterWrite (&Reset);
 
+	debug_printf_str(">>>>> wait2\n");
 	if (!DWHCIDeviceWaitForBit (pThis, &Reset, DWHCI_CORE_RESET_SOFT_RESET, FALSE, 10))
 	{
 		_DWHCIRegister (&Reset);
@@ -573,7 +600,9 @@ boolean DWHCIDeviceReset (TDWHCIDevice *pThis)
 		return FALSE;
 	}
 	
+	debug_printf_str(">>>>> delay\n");
 	MsDelay (100);
+	debug_printf_str(">>>>> delay done\n");
 
 	_DWHCIRegister (&Reset);
 
@@ -719,6 +748,7 @@ boolean DWHCIDeviceTransferStage (TDWHCIDevice *pThis, TUSBRequest *pURB, boolea
 	assert (!pThis->m_bWaiting);
 	pThis->m_bWaiting = TRUE;
 
+	debug_printf_str("x>> transfer async\n");
 	if (!DWHCIDeviceTransferStageAsync (pThis, pURB, bIn, bStatusStage))
 	{
 		pThis->m_bWaiting = FALSE;
@@ -726,11 +756,13 @@ boolean DWHCIDeviceTransferStage (TDWHCIDevice *pThis, TUSBRequest *pURB, boolea
 		return FALSE;
 	}
 
+	debug_printf_str("x>> wait\n");
 	while (pThis->m_bWaiting)
 	{
 		// do nothing
 		//portYIELD();
 		portYIELD_WITHIN_API();
+		debug_printf_str(":");
 	}
 
 	return USBRequestGetStatus (pURB);
@@ -758,19 +790,23 @@ boolean DWHCIDeviceTransferStageAsync (TDWHCIDevice *pThis, TUSBRequest *pURB, b
 	TDWHCITransferStageData *pStageData =
 		(TDWHCITransferStageData *) malloc (sizeof (TDWHCITransferStageData));
 	assert (pStageData != 0);
+	debug_printf_str("x>>> transfer stage data\n");
 	DWHCITransferStageData (pStageData, nChannel, pURB, bIn, bStatusStage);
 
 	assert (pThis->m_pStageData[nChannel] == 0);
 	pThis->m_pStageData[nChannel] = pStageData;
 
+	debug_printf_str("x>>> enable int\n");
 	DWHCIDeviceEnableChannelInterrupt (pThis, nChannel);
 	
 	if (!DWHCITransferStageDataIsSplit (pStageData))
 	{
+		debug_printf_str("x>>> setstage\n");
 		DWHCITransferStageDataSetState (pStageData, StageStateNoSplitTransfer);
 	}
 	else
 	{
+		debug_printf_str("x>>> beginsplit\n");
 		if (!DWHCITransferStageDataBeginSplitCycle (pStageData))
 		{
 			DWHCIDeviceDisableChannelInterrupt (pThis, nChannel);
@@ -785,15 +821,19 @@ boolean DWHCIDeviceTransferStageAsync (TDWHCIDevice *pThis, TUSBRequest *pURB, b
 			return FALSE;
 		}
 
+		debug_printf_str("x>>> setstage\n");
 		DWHCITransferStageDataSetState (pStageData, StageStateStartSplit);
+		debug_printf_str("x>>> splitcomp\n");
 		DWHCITransferStageDataSetSplitComplete (pStageData, FALSE);
 		
 		TDWHCIFrameScheduler *pFrameScheduler =
 			DWHCITransferStageDataGetFrameScheduler (pStageData);
 		assert (pFrameScheduler != 0);
+		debug_printf_str("x>>> startsplit\n");
 		pFrameScheduler->StartSplit (pFrameScheduler);
 	}
 
+	debug_printf_str("x>>> starttran\n");
 	DWHCIDeviceStartTransaction (pThis, pStageData);
 	
 	return TRUE;
diff --git a/Drivers/lan9514/lib/dwhcirootport.c b/Drivers/lan9514/lib/dwhcirootport.c
index 257151a..4e46642 100644
--- a/Drivers/lan9514/lib/dwhcirootport.c
+++ b/Drivers/lan9514/lib/dwhcirootport.c
@@ -23,6 +23,7 @@
 #include <uspi/usbstandardhub.h>
 #include <uspi/assert.h>
 #include <uspios.h>
+#include <debug-printf.h>
 
 static const char FromDWHCIRoot[] = "dwroot";
 
@@ -55,6 +56,7 @@ boolean DWHCIRootPortInitialize (TDWHCIRootPort *pThis)
 	assert (pThis != 0);
 
 	assert (pThis->m_pHost != 0);
+	debug_printf_str(">>>> getspeed\n");
 	TUSBSpeed Speed = DWHCIDeviceGetPortSpeed (pThis->m_pHost);
 	if (Speed == USBSpeedUnknown)
 	{
@@ -69,6 +71,7 @@ boolean DWHCIRootPortInitialize (TDWHCIRootPort *pThis)
 	assert (pThis->m_pDevice != 0);
 	USBDevice (pThis->m_pDevice, pThis->m_pHost, Speed, 0, 1);
 
+	debug_printf_str(">>>> devinit\n");
 	if (!USBDeviceInitialize (pThis->m_pDevice))
 	{
 		_USBDevice (pThis->m_pDevice);
@@ -86,6 +89,7 @@ boolean DWHCIRootPortInitialize (TDWHCIRootPort *pThis)
 	_String (pNames);
 	free (pNames);
 
+	debug_printf_str(">>>> getdev\n");
 	// now create specific device from default device
 	TUSBDevice *pChild = USBDeviceFactoryGetDevice (pThis->m_pDevice);
 	if (pChild != 0)
diff --git a/Drivers/lan9514/lib/usbconfigparser.c b/Drivers/lan9514/lib/usbconfigparser.c
index 80218b8..baeeb22 100644
--- a/Drivers/lan9514/lib/usbconfigparser.c
+++ b/Drivers/lan9514/lib/usbconfigparser.c
@@ -181,7 +181,7 @@ void USBConfigurationParserError (TUSBConfigurationParser *pThis, const char *pS
 	LogWrite (pSource, LOG_ERROR,
 		     "Invalid configuration descriptor (offset 0x%X)",
 		     (unsigned) pThis->m_pErrorPosition - (unsigned) pThis->m_pBuffer);
-#ifndef NDEBUG
-	DebugHexdump (pThis->m_pBuffer, pThis->m_nBufLen, pSource);
-#endif
+/* #ifndef NDEBUG */
+/* 	DebugHexdump (pThis->m_pBuffer, pThis->m_nBufLen, pSource); */
+/* #endif */
 }
diff --git a/Drivers/lan9514/lib/usbdevice.c b/Drivers/lan9514/lib/usbdevice.c
index 5aceb4c..f449b4d 100644
--- a/Drivers/lan9514/lib/usbdevice.c
+++ b/Drivers/lan9514/lib/usbdevice.c
@@ -23,6 +23,7 @@
 #include <uspios.h>
 #include <uspi/util.h>
 #include <uspi/assert.h>
+#include <debug-printf.h>
 
 #define MAX_CONFIG_DESC_SIZE		512		// best guess
 
@@ -170,6 +171,7 @@ boolean USBDeviceInitialize (TUSBDevice *pThis)
 	assert (pThis->m_pHost != 0);
 	assert (pThis->m_pEndpoint0 != 0);
 	
+	debug_printf_str(">>>>> getdesc\n");
 	assert (sizeof *pThis->m_pDeviceDesc >= USB_DEFAULT_MAX_PACKET_SIZE);
 	if (DWHCIDeviceGetDescriptor (pThis->m_pHost, pThis->m_pEndpoint0,
 				    DESCRIPTOR_DEVICE, DESCRIPTOR_INDEX_DEFAULT,
@@ -195,6 +197,7 @@ boolean USBDeviceInitialize (TUSBDevice *pThis)
 		return FALSE;
 	}
 
+	debug_printf_str(">>>>> getdesc2\n");
 	USBEndpointSetMaxPacketSize (pThis->m_pEndpoint0, pThis->m_pDeviceDesc->bMaxPacketSize0);
 
 	if (DWHCIDeviceGetDescriptor (pThis->m_pHost, pThis->m_pEndpoint0,
diff --git a/Drivers/lan9514/lib/uspilibrary.c b/Drivers/lan9514/lib/uspilibrary.c
index b65e03b..483b976 100644
--- a/Drivers/lan9514/lib/uspilibrary.c
+++ b/Drivers/lan9514/lib/uspilibrary.c
@@ -24,6 +24,7 @@
 #include <uspi/string.h>
 #include <uspi/util.h>
 #include <uspi/assert.h>
+#include <debug-printf.h>
 
 static const char FromUSPi[] = "uspi";
 
@@ -31,6 +32,7 @@ static TUSPiLibrary *s_pLibrary = 0;
 
 int USPiInitialize (void)
 {
+	debug_printf_str(">> USPiInitialise\n");
 	assert (s_pLibrary == 0);
 	s_pLibrary = (TUSPiLibrary *) malloc (sizeof (TUSPiLibrary));
 	assert (s_pLibrary != 0);
@@ -39,6 +41,7 @@ int USPiInitialize (void)
 	DWHCIDevice (&s_pLibrary->DWHCI);
 	s_pLibrary->pEth0 = 0;
 
+	debug_printf_str(">> USPiDeviceInitialise\n");
 	if (!DWHCIDeviceInitialize (&s_pLibrary->DWHCI))
 	{
 		LogWrite (FromUSPi, LOG_ERROR, "Cannot initialize USB host controller interface");
@@ -50,6 +53,7 @@ int USPiInitialize (void)
 
 		return 0;
 	}
+	debug_printf_str("   success\n");
 
 	s_pLibrary->pUKBD1 = (TUSBKeyboardDevice *) DeviceNameServiceGetDevice (DeviceNameServiceGet (), "ukbd1", FALSE);
 
@@ -67,6 +71,7 @@ int USPiInitialize (void)
 		_String  (&DeviceName);
 	}
 
+	debug_printf_str(">> USPi eth0\n");
 	s_pLibrary->pEth0 = (TSMSC951xDevice *) DeviceNameServiceGetDevice (DeviceNameServiceGet (), "eth0", FALSE);
 
 	for (unsigned i = 0; i < MAX_DEVICES; i++)
diff --git a/Drivers/lan9514/uspibind.c b/Drivers/lan9514/uspibind.c
index 391b89f..fab91db 100644
--- a/Drivers/lan9514/uspibind.c
+++ b/Drivers/lan9514/uspibind.c
@@ -18,34 +18,38 @@
 // along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 #include <uspios.h>
-#include <FreeRTOS.h>
-#include <task.h>
-#include <video.h>
 #include <mailbox.h>
-#include <mem.h>
+#include <debug-printf.h>
 
 __attribute__((no_instrument_function))
 void MsDelay (unsigned nMilliSeconds){
-	volatile int* timeStamp = (int*)0x3f003004;
-	int stop = *timeStamp + nMilliSeconds * 1000;
-	while (*timeStamp < stop) __asm__("nop");
+	debug_printf("delay %i ms\n", nMilliSeconds);
+	volatile uint32_t*const timeStamp = (volatile uint32_t*)0x3f003004;
+	uint32_t start = *timeStamp;
+	uint32_t delta = nMilliSeconds * 1000;
+	while (((*timeStamp) - start) < delta) {
+		debug_putc('.');
+//		__asm__("dmb");
+	}
 	//vTaskDelay(nMilliSeconds);
+	debug_printf_str("delay done\n");
 }
 
 __attribute__((no_instrument_function))
 void usDelay (unsigned nMicroSeconds){
-	volatile int* timeStamp = (int*)0x3f003004;
-	int stop = *timeStamp + nMicroSeconds;
-	while (*timeStamp < stop) __asm__("nop");
+	debug_printf("delay %i us\n", nMicroSeconds);
+	volatile uint32_t*const timeStamp = (volatile uint32_t*)0x3f003004;
+	uint32_t start = *timeStamp;
+	uint32_t delta = nMicroSeconds;
+	while (((*timeStamp) - start) < delta) __asm__("dmb");
+	debug_printf_str("delay done\n");
 }
 
 unsigned StartKernelTimer (unsigned nDelay, TKernelTimerHandler *pHandler, void *pParam, void *pContext){
-	println("StartKernelTimer", 0xFFFFFFFF);
 	return 1;//TimerStartKernelTimer (TimerGet (), nDelay, pHandler, pParam, pContext);
 }
 
 void CancelKernelTimer (unsigned hTimer){
-	println("CancelKernelTimer", 0xFFFFFFFF);//TimerCancelKernelTimer (TimerGet (), hTimer);
 }
 
 //void ConnectInterrupt (unsigned nIRQ, TInterruptHandler *pfnHandler, void *pParam){
@@ -70,8 +74,10 @@ int SetPowerStateOn (unsigned nDeviceId){
 	mailbuffer[7] = 0;			//terminate buffer
 
 	//spam mail until the response code is ok
-	while(mailbuffer[1] != 0x80000000){
+	while (mailbuffer[1] != 0x80000000) {
+		debug_printf_str(":");
 		mailboxWrite((int)mailbuffer, 8);
+		debug_printf_str(";");
 		mailboxRead(8);
 	}
 
@@ -109,44 +115,25 @@ int GetMACAddress (unsigned char Buffer[6]){
 	return 1;
 }
 
+#ifndef NDEBUG
+#include <debug-printf.h>
+
 __attribute__((no_instrument_function))
 void LogWrite (const char *pSource, unsigned Severity, const char *pMessage, ...)
 {
-	/*va_list var;
+	va_list var;
 	va_start (var, pMessage);
 
-	LoggerWriteV (LoggerGet (), pSource, (TLogSeverity) Severity, pMessage, var);
+	debug_printf("[%s | %u] ", pSource, Severity);
+	debug_vprintf(pMessage, var);
+	debug_printf_str("\n");
 
-	va_end (var);*/
-	println(pMessage, 0xFFFFFFFF);
+	va_end (var);
 }
 
-#ifndef NDEBUG
-
 void uspi_assertion_failed (const char *pExpr, const char *pFile, unsigned nLine){	
-	println(pExpr, 0xFFFFFFFF);
-	println(pFile, 0xFFFFFFFF);
-	printHex("Line ", nLine, 0xFFFFFFFF);
+	debug_printf("*** USPI ASSERTION FAILED ***\n %s\n at %s:%u\n", pExpr, pFile, nLine);
 	while(1){;} //system failure
 }
 
-void DebugHexdump (const void *pBuffer, unsigned nBufLen, const char *pSource){
-	println("DebugHexdump", 0xFFFFFFFF);//debug_hexdump (pBuffer, nBufLen, pSource);
-}
-
 #endif
-
-void* malloc(unsigned nSize){
-	uspi_EnterCritical();
-//if(loaded == 2) println("malloc", 0xFFFFFFFF);
-	void* temp = pvPortMalloc(nSize);
-	uspi_LeaveCritical();
-	return temp;
-
-}
-
-void free(void* pBlock){
-	uspi_EnterCritical();
-	vPortFree(pBlock);
-	uspi_LeaveCritical();
-}
\ No newline at end of file
diff --git a/Drivers/mailbox.c b/Drivers/mailbox.c
index 0b424ec..1b7d38b 100644
--- a/Drivers/mailbox.c
+++ b/Drivers/mailbox.c
@@ -4,29 +4,34 @@
 //These functions are used for communications between the CPU and GPU
 
 #include <mailbox.h>
+#include <debug-printf.h>
 
 //direct memory get and set
-extern void PUT32(int dest, int src);
-extern int GET32(int src);
+#define PUT32(dest, val) (*(volatile uint32_t*)(void*)(intptr_t)(dest)) = (val)
+#define GET32(src) (*(volatile uint32_t*)(void*)(intptr_t)(src))
+
+#define DataMemBarrier() 	__asm volatile ("dmb" ::: "memory")
+static const int mailbox = 0x3f00B880;
 
 //Docuentation on the mailbox functions
 //mailbuffer should probably be 16 byte aligned (for gpu at least):
 //unsigned int mailbuffer[22] __attribute__((aligned (16)));
 //https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface
 void mailboxWrite(int data_addr, int channel){
-	int mailbox = 0x3f00B880;
 	while(1){
+		DataMemBarrier ();
 		if((GET32(mailbox + 0x18)&0x80000000) == 0) break;
 	}
 	PUT32(mailbox + 0x20, data_addr + channel);
+	DataMemBarrier ();
 	return;
 }
 
 int mailboxRead(int channel){
 	int ra;
-	int mailbox = 0x3f00B880;
 	while(1){
 		while(1){
+			DataMemBarrier ();
 			ra = GET32(mailbox + 0x18);
 			if((ra&0x40000000) == 0) break;
 		}
diff --git a/FreeRTOS/Source/include/FreeRTOSConfig.h b/FreeRTOS/Source/include/FreeRTOSConfig.h
index 49b1a78..0a4db7c 100644
--- a/FreeRTOS/Source/include/FreeRTOSConfig.h
+++ b/FreeRTOS/Source/include/FreeRTOSConfig.h
@@ -82,34 +82,65 @@
 #define configUSE_MUTEXES 1
 #define configUSE_COUNTING_SEMAPHORES 1
 #define configUSE_PREEMPTION		1
-#define configUSE_IDLE_HOOK			0
-#define configUSE_TICK_HOOK			0
+#define configUSE_TICKLESS_IDLE					0
+#define configUSE_IDLE_HOOK			1
+#define configUSE_TICK_HOOK			1
 #define configCPU_CLOCK_HZ			( ( unsigned long ) 24000000 )	
 #define configTICK_RATE_HZ			( ( portTickType ) 1000 )
-#define configMAX_PRIORITIES		( ( unsigned portBASE_TYPE ) 5 )
-#define configMINIMAL_STACK_SIZE	( ( unsigned short ) 128 )
+#define configMAX_PRIORITIES		5
+#define configMINIMAL_STACK_SIZE	( ( unsigned short ) 256 )
+#define configTIMER_TASK_STACK_DEPTH	( configMINIMAL_STACK_SIZE * 2 )
 #define configTOTAL_HEAP_SIZE		( ( size_t ) ( 122880 ) )
 #define configMAX_TASK_NAME_LEN		( 16 )
-#define configUSE_TRACE_FACILITY	0
+#define configUSE_TRACE_FACILITY	1
 #define configUSE_16_BIT_TICKS		0
 #define configIDLE_SHOULD_YIELD		1
-#define configUSE_APPLICATION_TASK_TAG	1
+#define configUSE_MUTEXES						1
+#define configQUEUE_REGISTRY_SIZE				8
+#define configCHECK_FOR_STACK_OVERFLOW			2
+#define configUSE_RECURSIVE_MUTEXES				1
+#define configUSE_MALLOC_FAILED_HOOK			1
+#define configUSE_APPLICATION_TASK_TAG			0
+#define configUSE_COUNTING_SEMAPHORES			1
+#define configUSE_QUEUE_SETS					1
+#define configSUPPORT_STATIC_ALLOCATION			1
+#define configTASK_NOTIFICATION_ARRAY_ENTRIES   4
+#define configUSE_NEWLIB_REENTRANT              0 // picolibc uses TLS instead of reent.h
+#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 1 // used for __thread keyword support
 
 /* Co-routine definitions. */
 #define configUSE_CO_ROUTINES 		0
 #define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
 
+/* Software timer definitions. */
+#define configUSE_TIMERS						1
+#define configTIMER_TASK_PRIORITY				( configMAX_PRIORITIES - 1 )
+#define configTIMER_QUEUE_LENGTH				5
+#define configTIMER_TASK_STACK_DEPTH			( configMINIMAL_STACK_SIZE * 2 )
+
+/* If configUSE_TASK_FPU_SUPPORT is set to 1 (or undefined) then each task will
+be created without an FPU context, and a task must call vTaskUsesFPU() before
+making use of any FPU registers.  If configUSE_TASK_FPU_SUPPORT is set to 2 then
+tasks are created with an FPU context by default, and calling vTaskUsesFPU() has
+no effect. */
+#define configUSE_TASK_FPU_SUPPORT				2
+
 /* Set the following definitions to 1 to include the API function, or zero
 to exclude the API function. */
 
-#define INCLUDE_vTaskPrioritySet		1
-#define INCLUDE_uxTaskPriorityGet		1
-#define INCLUDE_vTaskDelete				1
-#define INCLUDE_vTaskCleanUpResources	0
-#define INCLUDE_vTaskSuspend			1
-#define INCLUDE_vTaskDelayUntil			1
-#define INCLUDE_vTaskDelay				1
-#define INCLUDE_xTaskGetCurrentTaskHandle 1
+#define INCLUDE_vTaskPrioritySet				1
+#define INCLUDE_uxTaskPriorityGet				1
+#define INCLUDE_vTaskDelete						1
+#define INCLUDE_vTaskCleanUpResources			1
+#define INCLUDE_vTaskSuspend					1
+#define INCLUDE_vTaskDelayUntil					1
+#define INCLUDE_vTaskDelay						1
+#define INCLUDE_xTimerPendFunctionCall			1
+#define INCLUDE_eTaskGetState					1
+#define INCLUDE_xTaskAbortDelay					1
+#define INCLUDE_xTaskGetTaskHandle				1
+#define INCLUDE_xTaskGetHandle					1
+#define INCLUDE_xSemaphoreGetMutexHolder		1
 
 /* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
 (lowest) to 0 (1?) (highest). */
@@ -125,5 +156,11 @@ configKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
 NVIC value of 255. */
 #define configLIBRARY_KERNEL_INTERRUPT_PRIORITY	15
 
+/* FreeRTOS-plus-CLI */
+#define configCOMMAND_INT_MAX_OUTPUT_SIZE 2096
+
+#define configLIST_VOLATILE volatile
+
+
 #endif /* FREERTOS_CONFIG_H */
 
diff --git a/FreeRTOS/Source/portable/GCC/RaspberryPi/port.c b/FreeRTOS/Source/portable/GCC/RaspberryPi/port.c
index df72395..fb4531e 100644
--- a/FreeRTOS/Source/portable/GCC/RaspberryPi/port.c
+++ b/FreeRTOS/Source/portable/GCC/RaspberryPi/port.c
@@ -5,15 +5,21 @@
 #include "FreeRTOS.h"
 #include "task.h"
 #include <interrupts.h>
+#include <string.h>
+#include <debug-printf.h>
 
 /* Constants required to setup the task context. */
 #define portINITIAL_SPSR						( ( portSTACK_TYPE ) 0x1f ) /* System mode, ARM mode, interrupts enabled. */
 #define portTHUMB_MODE_BIT						( ( portSTACK_TYPE ) 0x20 )
 #define portINSTRUCTION_SIZE					( ( portSTACK_TYPE ) 4 )
 #define portNO_CRITICAL_SECTION_NESTING			( ( portSTACK_TYPE ) 0 )
+#define portNO_FLOATING_POINT_CONTEXT			( ( portSTACK_TYPE ) 0 )
 
-#define portTIMER_PRESCALE 						( ( unsigned long ) 0xF9 )
+/* The space on the stack required to hold the FPU registers.  This is 32 64-bit
+registers, plus a 32-bit status register. */
+#define portFPU_REGISTER_WORDS	( ( 32 * 2 ) + 1 )
 
+#define portTIMER_PRESCALE 						( ( unsigned long ) 0xF9 )
 
 /* Constants required to setup the VIC for the tick ISR. */
 #define portTIMER_BASE                    		( (unsigned long ) 0x3f00B400 )
@@ -32,6 +38,10 @@ typedef struct _BCM2835_TIMER_REGS {
 
 static volatile BCM2835_TIMER_REGS * const pRegs = (BCM2835_TIMER_REGS *) (portTIMER_BASE);
 
+/* Saved as part of the task context.  If ulPortTaskHasFPUContext is non-zero then
+a floating point context must be saved and restored for the task. */
+volatile uint32_t ulPortTaskHasFPUContext = pdFALSE;
+
 /*-----------------------------------------------------------*/
 
 /* Setup the timer to generate the tick interrupts. */
@@ -41,7 +51,16 @@ static void prvSetupTimerInterrupt( void );
  * The scheduler can only be started from ARM mode, so 
  * vPortISRStartFirstSTask() is defined in portISR.c. 
  */
-extern void vPortISRStartFirstTask( void );
+extern void vPortRestoreTaskContext( void );
+
+
+__attribute__((weak))
+void vPortTaskExitError( void ) {
+	configASSERT( ulPortInterruptNesting == ~0UL );
+	portDISABLE_INTERRUPTS();
+	for( ;; );
+}
+
 
 /*-----------------------------------------------------------*/
 
@@ -54,27 +73,36 @@ extern void vPortISRStartFirstTask( void );
 __attribute__((no_instrument_function))
 portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
 {
-portSTACK_TYPE *pxOriginalTOS;
+	/* some padding to ease debugging */
+	*pxTopOfStack = ( portSTACK_TYPE ) NULL;
+	pxTopOfStack--;
+	*pxTopOfStack = ( portSTACK_TYPE ) NULL;
+	pxTopOfStack--;
+	*pxTopOfStack = ( portSTACK_TYPE ) NULL;
+	pxTopOfStack--;
 
-	pxOriginalTOS = pxTopOfStack;
+	/* The first thing onto the stack is the status register, which is set for
+	system mode, with interrupts enabled. */
+	*pxTopOfStack = ( portSTACK_TYPE ) portINITIAL_SPSR;
+
+	if( ( ( unsigned long ) pxCode & 0x01UL ) != 0x00 )
+	{
+		/* We want the task to start in thumb mode. */
+		*pxTopOfStack |= portTHUMB_MODE_BIT;
+	}
 
-	/* To ensure asserts in tasks.c don't fail, although in this case the assert
-	is not really required. */
 	pxTopOfStack--;
 
-	/* Setup the initial stack of the task.  The stack is set exactly as 
+	/* Setup the initial stack of the task.  The stack is set exactly as
 	expected by the portRESTORE_CONTEXT() macro. */
 
 	/* First on the stack is the return address - which in this case is the
-	start of the task.  The offset is added to make the return address appear
-	as it would within an IRQ ISR. */
-	*pxTopOfStack = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE;		
+	start of the task. */
+	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;
 	pxTopOfStack--;
 
-	*pxTopOfStack = ( portSTACK_TYPE ) 0xaaaaaaaa;	/* R14 */
+	*pxTopOfStack = ( portSTACK_TYPE ) vPortTaskExitError;	/* R14 */
 	pxTopOfStack--;	
-	*pxTopOfStack = ( portSTACK_TYPE ) pxOriginalTOS; /* Stack used when task starts goes in R13. */
-	pxTopOfStack--;
 	*pxTopOfStack = ( portSTACK_TYPE ) 0x12121212;	/* R12 */
 	pxTopOfStack--;	
 	*pxTopOfStack = ( portSTACK_TYPE ) 0x11111111;	/* R11 */
@@ -105,36 +133,51 @@ portSTACK_TYPE *pxOriginalTOS;
 	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters; /* R0 */
 	pxTopOfStack--;
 
-	/* The last thing onto the stack is the status register, which is set for
-	system mode, with interrupts enabled. */
-	*pxTopOfStack = ( portSTACK_TYPE ) portINITIAL_SPSR;
-
-	if( ( ( unsigned long ) pxCode & 0x01UL ) != 0x00 )
-	{
-		/* We want the task to start in thumb mode. */
-		*pxTopOfStack |= portTHUMB_MODE_BIT;
-	}
-
-	pxTopOfStack--;
-
-	/* Some optimisation levels use the stack differently to others.  This 
+	/* Some optimisation levels use the stack differently to others.  This
 	means the interrupt flags cannot always be stored on the stack and will
 	instead be stored in a variable, which is then saved as part of the
 	tasks context. */
 	*pxTopOfStack = portNO_CRITICAL_SECTION_NESTING;
 
+	#if( configUSE_TASK_FPU_SUPPORT == 1 )
+	{
+		/* The task will start without a floating point context.  A task that
+		uses the floating point hardware must call vPortTaskUsesFPU() before
+		executing any floating point instructions. */
+		pxTopOfStack--;
+		*pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
+	}
+	#elif( configUSE_TASK_FPU_SUPPORT == 2 )
+	{
+		/* The task will start with a floating point context.  Leave enough
+		space for the registers - and ensure they are initialised to 0. */
+		pxTopOfStack -= portFPU_REGISTER_WORDS;
+		memset( pxTopOfStack, 0x00, portFPU_REGISTER_WORDS * sizeof( StackType_t ) );
+
+		pxTopOfStack--;
+		*pxTopOfStack = pdTRUE;
+		ulPortTaskHasFPUContext = pdTRUE;
+	}
+	#else
+	{
+		#error Invalid configUSE_TASK_FPU_SUPPORT setting - configUSE_TASK_FPU_SUPPORT must be set to 1, 2, or left undefined.
+	}
+	#endif
+
 	return pxTopOfStack;
 }
 /*-----------------------------------------------------------*/
 __attribute__((no_instrument_function))
 portBASE_TYPE xPortStartScheduler( void )
 {
+	debug_printf_str("== timer\n"); if (1) { extern void prvSetupLocalTimerInterrupt(); prvSetupLocalTimerInterrupt(); } else
 	/* Start the timer that generates the tick ISR.  Interrupts are disabled
 	here already. */
 	prvSetupTimerInterrupt();
 
+	debug_printf_str("== ctx\n");
 	/* Start the first task. */
-	vPortISRStartFirstTask();	
+	vPortRestoreTaskContext();
 
 	/* Should not get here! */
 	return 0;
@@ -157,11 +200,9 @@ void vPortEndScheduler( void )
 __attribute__((no_instrument_function))
 void vTickISR(int nIRQ, void *pParam )
 {
-	vTaskIncrementTick();
+	BaseType_t switch_needed = xTaskIncrementTick();
 
-	#if configUSE_PREEMPTION == 1
-	vTaskSwitchContext();
-	#endif
+	if (switch_needed) vTaskSwitchContext();
 
 	pRegs->CLI = 0;			// Acknowledge the timer interrupt.
 }
@@ -203,3 +244,18 @@ static void prvSetupTimerInterrupt( void )
 }
 /*-----------------------------------------------------------*/
 
+#if( configUSE_TASK_FPU_SUPPORT != 2 )
+
+void vPortTaskUsesFPU( void )
+{
+	uint32_t ulInitialFPSCR = 0;
+
+	/* A task is registering the fact that it needs an FPU context.  Set the
+	   FPU flag (which is saved as part of the task context). */
+	ulPortTaskHasFPUContext = pdTRUE;
+
+	/* Initialise the floating point status register. */
+	__asm volatile ( "FMXR 	FPSCR, %0" :: "r" (ulInitialFPSCR) : "memory" );
+}
+
+#endif /* configUSE_TASK_FPU_SUPPORT */
diff --git a/FreeRTOS/Source/portable/GCC/RaspberryPi/portisr.c b/FreeRTOS/Source/portable/GCC/RaspberryPi/portisr.c
index da7f2cc..ae0f76d 100644
--- a/FreeRTOS/Source/portable/GCC/RaspberryPi/portisr.c
+++ b/FreeRTOS/Source/portable/GCC/RaspberryPi/portisr.c
@@ -35,7 +35,7 @@
 volatile unsigned long ulCriticalNesting = 9999UL;
 
 /*-----------------------------------------------------------*/
-
+#if 0 // moved to separate assembly file
 /* ISR to handle manual context switches (from a call to taskYIELD()). */
 void vPortYieldProcessor( void ) __attribute__((interrupt("SWI"), naked, no_instrument_function));
 
@@ -168,7 +168,7 @@ void vFreeRTOS_ISR( void ) {
 	}
 
 #endif /* THUMB_INTERWORK */
-
+#endif
 /* The code generated by the GCC compiler uses the stack in different ways at
 different optimisation levels.  The interrupt flags can therefore not always
 be saved to the stack.  Instead the critical section nesting level is stored
diff --git a/FreeRTOS/Source/portable/GCC/RaspberryPi/portmacro.h b/FreeRTOS/Source/portable/GCC/RaspberryPi/portmacro.h
index c516ba6..36fc76f 100644
--- a/FreeRTOS/Source/portable/GCC/RaspberryPi/portmacro.h
+++ b/FreeRTOS/Source/portable/GCC/RaspberryPi/portmacro.h
@@ -1,6 +1,8 @@
 #ifndef PORTMACRO_H
 #define PORTMACRO_H
 
+#include <stdint.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -31,11 +33,17 @@ extern "C" {
 	typedef unsigned portLONG portTickType;
 	#define portMAX_DELAY ( portTickType ) 0xffffffff
 #endif
+
+typedef portSTACK_TYPE StackType_t;
+typedef portBASE_TYPE BaseType_t;
+typedef unsigned portBASE_TYPE UBaseType_t;
+typedef portTickType TickType_t;
+
 /*-----------------------------------------------------------*/	
 
 /* Architecture specifics. */
 #define portSTACK_GROWTH			( -1 )
-#define portTICK_RATE_MS			( ( portTickType ) 1000 / configTICK_RATE_HZ )		
+#define portTICK_PERIOD_MS			( ( portTickType ) 1000 / configTICK_RATE_HZ )
 #define portBYTE_ALIGNMENT			8
 #define portNOP()						__asm volatile ( "NOP" );
 /*-----------------------------------------------------------*/	
@@ -43,6 +51,7 @@ extern "C" {
 
 /* Scheduler utilities. */
 
+#if 0 // moved to separate assembly file
 /*
  * portSAVE_CONTEXT, portRESTORE_CONTEXT, portENTER_SWITCHING_ISR
  * and portEXIT_SWITCHING_ISR can only be called from ARM mode, but
@@ -139,9 +148,10 @@ extern "C" {
 	( void ) ulCriticalNesting;												\
 	( void ) pxCurrentTCB;													\
 }
+#endif
 
 extern void vTaskSwitchContext( void );
-#define portYIELD_FROM_ISR()		vTaskSwitchContext()
+#define portYIELD_FROM_ISR(x)		vTaskSwitchContext()
 #define portYIELD()					__asm volatile ( "SWI 0" )
 /*-----------------------------------------------------------*/
 
@@ -190,6 +200,9 @@ extern void vPortExitCritical( void );
 #define portEXIT_CRITICAL()		vPortExitCritical();
 /*-----------------------------------------------------------*/
 
+extern void vCleanUpTCB( void* );
+#define portCLEAN_UP_TCB(x) vCleanUpTCB(x)
+
 /* Task function macros as described on the FreeRTOS.org WEB site. */
 #define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
 #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
